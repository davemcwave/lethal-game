<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lethal â€“ Daily Card Battler</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0e0e0e;
      --card-bg: rgba(255, 255, 255, 0.05);
      --card-bg-expanded: rgba(20, 20, 20, 0.95);
      --card-border: rgba(255, 255, 255, 0.1);
      --highlight: #5eead4;
      --text: #f0f0f0;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'Space Grotesk', sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 2rem;
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh;
    }
    h1 { margin-bottom: 2rem; color: var(--highlight); }
    /* Enemy Section */
    .enemy { text-align: center; margin-bottom: 2rem; position: relative; }
    .enemy img { width: 100px; }
    .hp-label { color: white; font-size: 0.9rem; text-align: center; margin-bottom: 0.25rem; }
    .hp-fill {
      background: #ef4444; height: 100%; width: 100%; transition: width 0.3s ease;
    }
    /* Play Area */
    .play-area {
      display: flex; flex-wrap: wrap; gap: 1rem;
      border: 2px dashed #444; min-height: 300px;
      width: 100%; max-width: 600px; padding: 1rem; margin-bottom: 2rem;
    }
    /* Hand (Cards container) */
    .hand { display: flex; gap: 1rem; justify-content: center; margin-top: 2rem; }
    /* Card and Drop Preview â€“ Compact State */
    .card, .drop-preview {
      width: 70px; height: 110px; border-radius: 0.75rem; padding: 0.5rem;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 0.35rem; transition: background 0.2s ease; overflow: hidden;
      position: relative; background: var(--card-bg); box-sizing: border-box;
      touch-action: none; /* Prevent default scrolling on mobile */
    }
    .card {
      border: 2px solid var(--card-border); cursor: grab;
      box-shadow: 0 0 10px rgba(0,0,0,0.4);
    }
    .drop-preview {
      border: 2px dashed rgba(255,255,255,0.25);
      background-color: rgba(255,255,255,0.05);
    }
    .card img {
      width: 32px; height: 32px; pointer-events: none; display: block; margin: 0 auto;
    }
    .card-title {
      font-size: 0.8rem; color: var(--highlight);
      text-align: center; white-space: nowrap;
      overflow: hidden; text-overflow: ellipsis;
    }
    .card-desc { display: none; font-size: 0.75rem; color: #aaa; text-align: center; }
    .card.active {
      outline: 3px solid var(--highlight);
      box-shadow: 0 0 12px var(--highlight);
    }
    /* Card Overlay for Expanded View (Preview) */
    #cardOverlay {
      display: none; /* Initially hidden */
      position: fixed;
      background: var(--card-bg-expanded);
      border: 2px solid var(--card-border);
      border-radius: 0.75rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
      z-index: 15000;
      overflow: hidden;
    }
    @media (min-width: 600px) {
      #cardOverlay { width: 200px; height: 300px; padding: 1rem; }
    }
    @media (max-width: 600px) {
      #cardOverlay {
        width: 100vw; height: 100vh; padding: 0.5rem;
        left: 0; top: 0;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        text-align: center;
      }
    }
    #cardOverlay .card-title { font-size: 1.2rem; }
    #cardOverlay .card-desc {
      display: block; font-size: 1rem; margin-top: 0.5rem;
    }
    #cardOverlay img { display: block; margin: 0 auto; }
    /* Victory Overlay */
    #victoryOverlay {
      display: none; position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh; background: rgba(0,0,0,0.8);
      z-index: 9500; align-items: center; justify-content: center;
    }
    .fadeIn { animation: overlayFadeIn 0.8s forwards; }
    @keyframes overlayFadeIn { from { opacity: 0; } to { opacity: 1; } }
    #winAnimation {
      font-size: 2.5rem; font-weight: bold; color: var(--highlight);
      opacity: 0; animation: fadeInText 1s forwards;
    }
    @keyframes fadeInText { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
    /* End Game Modal */
    #endScreen {
      display: none; position: fixed; top: 0; left: 0;
      width: 100vw; height: 100vh; background: rgba(0,0,0,0.65);
      z-index: 9999; justify-content: center; align-items: center;
      backdrop-filter: blur(3px);
    }
    #endScreenInner {
      background: #1a1a1a; border-radius: 0.75rem;
      padding: 1.5rem; width: 300px; text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      animation: fadeInModal 0.4s ease-out;
    }
    @keyframes fadeInModal { from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); } }
    #shareBlock {
      background: #0e0e0e; border: 1px solid #444; padding: 0.75rem;
      margin: 1rem 0; border-radius: 0.5rem; font-size: 0.9rem;
      color: var(--text); white-space: pre-wrap;
      text-align: left; width: 100%; max-width: 280px;
    }
    #copyBtn {
      background: var(--highlight); border: none;
      padding: 0.5rem 1rem; border-radius: 0.5rem;
      font-weight: bold; cursor: pointer;
    }
    /* Stylized Submit Button */
    .submit-btn {
      background: linear-gradient(45deg, #5eead4, #34d399);
      color: white; padding: 0.75rem 1.5rem;
      border: none; border-radius: 8px;
      font-size: 1.2rem; font-weight: bold;
      cursor: pointer; box-shadow: 0 4px 8px rgba(0,0,0,0.15);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .submit-btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0,0,0,0.25);
    }
  </style>
</head>
<body>
  <h1>Lethal â€“ Daily Card Battler</h1>
  
  <!-- Enemy Section -->
  <div class="enemy">
    <img id="enemyIcon" alt="Enemy Icon" src=""/>
    <h2 id="enemyName" style="color: var(--highlight); margin: 0.5rem 0;"></h2>
    <div style="margin: 1rem auto; max-width: 200px;">
      <div class="hp-label" id="enemyHPLabel"></div>
      <div style="background: #222; border-radius: 8px; height: 20px; overflow: hidden;">
        <div class="hp-fill" id="enemyHPFill"></div>
      </div>
    </div>
  </div>
  
  <!-- Play Order -->
  <div style="color: var(--highlight); font-weight: bold; margin-bottom: 0.5rem;">Play Order</div>
  <div class="play-area" id="playArea">
    <div class="drop-preview" id="previewMarker" style="display: none;"></div>
  </div>
  
  <!-- Submit Button -->
  <div class="submit-area">
    <button class="submit-btn">Submit</button>
  </div>
  
  <!-- Hand (Cards) - Populated from data.json -->
  <div class="hand" id="hand"></div>
  
  <!-- Hidden Result Log -->
  <div id="resultLog" style="display: none;"></div>
  
  <!-- Victory Overlay -->
  <div id="victoryOverlay">
    <div id="winAnimation">Victory</div>
  </div>
  
  <!-- End Game Modal -->
  <div id="endScreen">
    <div id="endScreenInner">
      <h2>ðŸŽ‰ You Defeated the Goblin King!</h2>
      <div id="shareBlock">â¬œâ¬œâ¬œ</div>
      <button id="copyBtn">Copy</button>
    </div>
  </div>
  
  <!-- Card Overlay for Expanded View (initially hidden) -->
  <div id="cardOverlay" style="display: none;"></div>
  
  <script>
    // Promote config to global scope for later use.
    let config = null;
  
    /******** LOAD CONFIG FROM data.json ********/
    fetch('data.json')
      .then(response => response.json())
      .then(cfg => {
        config = cfg;
        window.config = config; // Make config globally available
        // Build a mapping for card damage lookup
        window.cardDamageMapping = {};
        config.playerCards.forEach(card => {
          window.cardDamageMapping[card.name.toLowerCase()] = card.damage;
        });
  
        /******** SETUP ENEMY ********/
        function setupEnemy() {
          document.getElementById("enemyIcon").src = config.enemy.icon;
          document.getElementById("enemyName").textContent = config.enemy.name;
          document.getElementById("enemyHPLabel").textContent =
            `HP: ${config.enemy.hp} / ${config.enemy.hp}`;
          document.getElementById("enemyHPFill").style.width = "100%";
        }
  
        /******** GENERATE PLAYER CARDS ********/
        function generatePlayerCards() {
          const handContainer = document.getElementById("hand");
          handContainer.innerHTML = "";
          config.playerCards.forEach(card => {
            const cardDiv = document.createElement("div");
            cardDiv.className = "card";
            cardDiv.innerHTML = `
              <img src="${card.icon}" alt="${card.name} Icon" />
              <div class="card-title">${card.name}</div>
              <div class="card-desc">${card.description}</div>
            `;
            handContainer.appendChild(cardDiv);
          });
        }
  
        setupEnemy();
        generatePlayerCards();
  
        // Use pointer events if supported; otherwise, fall back to touch or mouse.
        if (window.PointerEvent) {
          document.querySelectorAll(".card").forEach(card => {
            initCardEvents(card);
          });
        } else if ("ontouchstart" in window) {
          document.querySelectorAll(".card").forEach(card => {
            card.addEventListener("touchstart", handleTouchStart, {passive: false});
          });
        } else {
          document.querySelectorAll(".card").forEach(card => {
            card.addEventListener("mousedown", mouseDownHandler);
            card.addEventListener("click", mouseClickHandler);
            initDesktopOverlay(card);
          });
        }
      })
      .catch(error => { console.error("Error loading data.json:", error); });
  
    // Helper to reinitialize card events after a turn
    function rebindCardEvents() {
      document.querySelectorAll("#hand .card").forEach(card => {
        initCardEvents(card);
      });
    }
  
    /******** POINTER EVENT HANDLERS (Unified) ********/
    let draggedCard = null;
    let pointerStartX = 0, pointerStartY = 0;
    let dragOffsetX = 0, dragOffsetY = 0;
    let isDragging = false;
    let dragOrigin = null;
  
    function handlePointerDown(e) {
      e.preventDefault();
      hideCardOverlay();
      draggedCard = e.currentTarget;
      dragOrigin = draggedCard.parentNode.id;
      pointerStartX = e.clientX;
      pointerStartY = e.clientY;
      const rect = draggedCard.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      isDragging = false;
      // Attach pointer events
      draggedCard.setPointerCapture(e.pointerId);
      draggedCard.addEventListener("pointermove", handlePointerMove);
      draggedCard.addEventListener("pointerup", handlePointerUp);
    }
  
    function handlePointerMove(e) {
      const dx = e.clientX - pointerStartX;
      const dy = e.clientY - pointerStartY;
      if (!isDragging && Math.sqrt(dx*dx + dy*dy) > 10) { isDragging = true; }
      if (isDragging) {
        draggedCard.style.position = "absolute";
        draggedCard.style.zIndex = "1000";
        draggedCard.style.left = (e.clientX - dragOffsetX) + "px";
        draggedCard.style.top = (e.clientY - dragOffsetY) + "px";
      }
    }
  
    function handlePointerUp(e) {
      draggedCard.removeEventListener("pointermove", handlePointerMove);
      draggedCard.removeEventListener("pointerup", handlePointerUp);
      const dx = e.clientX - pointerStartX;
      const dy = e.clientY - pointerStartY;
      if (!isDragging && window.innerWidth < 600 && Math.sqrt(dx*dx+dy*dy) < 10) {
        // Treat as a tap on mobile: show overlay.
        showCardOverlay(draggedCard);
      } else {
        repositionCard(e.clientX, e.clientY);
      }
      if (draggedCard) {
        draggedCard.style.position = "";
        draggedCard.style.zIndex = "";
        draggedCard.style.left = "";
        draggedCard.style.top = "";
        draggedCard.style.pointerEvents = "";
        draggedCard.releasePointerCapture(e.pointerId);
        initCardEvents(draggedCard);
      }
      draggedCard = null;
    }
  
    function repositionCard(clientX, clientY) {
      const playArea = document.getElementById("playArea");
      const hand = document.getElementById("hand");
      const playRect = playArea.getBoundingClientRect();
      const handRect = hand.getBoundingClientRect();
      let parentToPlace;
      if (clientX > playRect.left && clientX < playRect.right &&
          clientY > playRect.top && clientY < playRect.bottom) {
        parentToPlace = playArea;
      } else if (clientX > handRect.left && clientX < handRect.right &&
                 clientY > handRect.top && clientY < handRect.bottom) {
        parentToPlace = hand;
      } else {
        parentToPlace = (dragOrigin === "hand") ? hand : playArea;
      }
      parentToPlace.appendChild(draggedCard);
    }
  
    function initCardEvents(card) {
      // Remove any existing pointerdown handler and then add a new one.
      card.removeEventListener("pointerdown", handlePointerDown);
      card.addEventListener("pointerdown", handlePointerDown);
      // Desktop preview events: if there is no touch device, use pointerenter/leave.
      if (navigator.maxTouchPoints === 0) {
        card.addEventListener("pointerenter", () => { if(!draggedCard) showCardOverlay(card); });
        card.addEventListener("pointerleave", hideCardOverlay);
        card.addEventListener("click", function(e) {
          if (!draggedCard) {
            if (document.getElementById("cardOverlay").style.display === "block") {
              hideCardOverlay();
            } else {
              showCardOverlay(card);
            }
          }
        });
      }
    }
  
    /******** FALLBACK MOUSE HANDLERS ********/
    function mouseDownHandler(e) {
      e.preventDefault();
      hideCardOverlay();
      draggedCard = e.currentTarget;
      dragOrigin = draggedCard.parentNode.id;
      const rect = draggedCard.getBoundingClientRect();
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;
      draggedCard.style.position = "absolute";
      draggedCard.style.zIndex = "1000";
      draggedCard.style.pointerEvents = "none";
      draggedCard.style.left = rect.left + "px";
      draggedCard.style.top = rect.top + "px";
      document.addEventListener("mousemove", mouseMoveHandler);
      document.addEventListener("mouseup", mouseUpHandler);
    }
  
    function mouseMoveHandler(e) {
      if (!draggedCard) return;
      hideCardOverlay();
      draggedCard.style.left = (e.clientX - dragOffsetX) + "px";
      draggedCard.style.top = (e.clientY - dragOffsetY) + "px";
    }
  
    function mouseUpHandler(e) {
      if (!draggedCard) return;
      const playArea = document.getElementById("playArea");
      const hand = document.getElementById("hand");
      const playRect = playArea.getBoundingClientRect();
      const handRect = hand.getBoundingClientRect();
      let parentToPlace;
      if (e.clientX > playRect.left && e.clientX < playRect.right &&
          e.clientY > playRect.top && e.clientY < playRect.bottom)
        parentToPlace = playArea;
      else if (e.clientX > handRect.left && e.clientX < handRect.right &&
               e.clientY > handRect.top && e.clientY < handRect.bottom)
        parentToPlace = hand;
      else
        parentToPlace = (dragOrigin === "hand") ? hand : playArea;
      draggedCard.style.position = "";
      draggedCard.style.zIndex = "";
      draggedCard.style.left = "";
      draggedCard.style.top = "";
      draggedCard.style.pointerEvents = "";
      parentToPlace.appendChild(draggedCard);
      document.removeEventListener("mousemove", mouseMoveHandler);
      document.removeEventListener("mouseup", mouseUpHandler);
      initCardEvents(draggedCard);
      draggedCard = null;
    }
  
    function mouseClickHandler(e) {
      if (!draggedCard) {
        if (document.getElementById("cardOverlay").style.display === "block")
          hideCardOverlay();
        else
          showCardOverlay(e.currentTarget);
      }
    }
  
    function initDesktopOverlay(card) {
      card.addEventListener("pointerenter", function() { if (!draggedCard) showCardOverlay(card); });
      card.addEventListener("pointerleave", hideCardOverlay);
    }
  
    /******** FALLBACK TOUCH HANDLERS (if PointerEvent unsupported) ********/
    let touchStartX = 0, touchStartY = 0;
    function handleTouchStart(e) {
      e.preventDefault();
      hideCardOverlay();
      draggedCard = e.currentTarget;
      dragOrigin = draggedCard.parentNode.id;
      const rect = draggedCard.getBoundingClientRect();
      const touch = e.touches[0];
      dragOffsetX = touch.clientX - rect.left;
      dragOffsetY = touch.clientY - rect.top;
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
      draggedCard.style.position = "absolute";
      draggedCard.style.zIndex = "1000";
      draggedCard.style.pointerEvents = "none";
      draggedCard.style.left = rect.left + "px";
      draggedCard.style.top = rect.top + "px";
      draggedCard.isDragging = false;
      draggedCard.addEventListener("touchmove", handleTouchMove, {passive: false});
      draggedCard.addEventListener("touchend", handleTouchEnd, {passive: false});
    }
    function handleTouchMove(e) {
      const touch = e.touches[0];
      if (!draggedCard) return;
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      if (Math.sqrt(dx*dx + dy*dy) > 10) { draggedCard.isDragging = true; }
      draggedCard.style.left = (touch.clientX - dragOffsetX) + "px";
      draggedCard.style.top = (touch.clientY - dragOffsetY) + "px";
      e.preventDefault();
    }
    function handleTouchEnd(e) {
      const touch = e.changedTouches[0];
      const dx = Math.abs(touch.clientX - touchStartX);
      const dy = Math.abs(touch.clientY - touchStartY);
      const distance = Math.sqrt(dx*dx + dy*dy);
      draggedCard.removeEventListener("touchmove", handleTouchMove);
      draggedCard.removeEventListener("touchend", handleTouchEnd);
      if (distance < 10 && !draggedCard.isDragging) {
        showCardOverlay(draggedCard);
      } else {
        const playArea = document.getElementById("playArea");
        const hand = document.getElementById("hand");
        const playRect = playArea.getBoundingClientRect();
        const handRect = hand.getBoundingClientRect();
        let parentToPlace;
        if (touch.clientX > playRect.left && touch.clientX < playRect.right &&
            touch.clientY > playRect.top && touch.clientY < playRect.bottom)
          parentToPlace = playArea;
        else if (touch.clientX > handRect.left && touch.clientX < handRect.right &&
                 touch.clientY > handRect.top && touch.clientY < handRect.bottom)
          parentToPlace = hand;
        else
          parentToPlace = (dragOrigin === "hand") ? hand : playArea;
        parentToPlace.appendChild(draggedCard);
      }
      if (draggedCard) {
        draggedCard.style.position = "";
        draggedCard.style.zIndex = "";
        draggedCard.style.left = "";
        draggedCard.style.top = "";
        draggedCard.style.pointerEvents = "";
        initCardEvents(draggedCard);
      }
      draggedCard = null;
    }
    if (!window.PointerEvent && "ontouchstart" in window) {
      document.querySelectorAll(".card").forEach(card => {
        card.addEventListener("touchstart", handleTouchStart, {passive: false});
      });
    }
  
    /******** SUBMIT TURN LOGIC ********/
    let lastPlayedTurn = [];
    document.querySelector(".submit-btn").addEventListener("click", () => {
      const playArea = document.getElementById("playArea");
      const cardTitles = Array.from(playArea.querySelectorAll(".card-title"));
      const hpFill = document.querySelector(".hp-fill");
      const hpLabel = document.querySelector(".hp-label");
      let currentHP = parseInt(hpLabel.textContent.split("/")[0].replace("HP:", "").trim());
      const getDamage = name => window.cardDamageMapping[name] || 0;
      const cardNames = cardTitles.map(title => title.textContent.trim().toLowerCase());
      addTurnResult(cardNames);
      lastPlayedTurn = [...cardNames];
      let i = 0;
      function playCardSequentially() {
        const allCards = document.querySelectorAll("#playArea .card");
        allCards.forEach(c => c.classList.remove("active"));
        if (i >= cardNames.length || currentHP <= 0) {
          if (currentHP <= 0) showWinMessage();
          else showFailedAttempt();
          return;
        }
        const currentCard = allCards[i];
        if (currentCard) { currentCard.classList.add("active"); }
        const damage = getDamage(cardNames[i]);
        currentHP = Math.max(0, currentHP - damage);
        const percent = (currentHP / window.config.enemy.hp) * 100;
        hpFill.style.width = percent + "%";
        hpLabel.textContent = `HP: ${currentHP} / ${window.config.enemy.hp}`;
        hpFill.style.background = "#f87171";
        setTimeout(() => {
          if (currentCard) { currentCard.classList.remove("active"); }
          hpFill.style.background = "#ef4444";
          i++;
          setTimeout(playCardSequentially, 500);
        }, 250);
      }
      playCardSequentially();
    });
  
    /******** END GAME MODAL LOGIC ********/
    function showWinMessage() {
      const enemy = document.querySelector(".enemy");
      enemy.style.animation = "enemyFall 1s ease forwards";
      setTimeout(() => {
        const victoryOverlay = document.getElementById("victoryOverlay");
        victoryOverlay.style.display = "flex";
        victoryOverlay.classList.add("fadeIn");
        setTimeout(() => {
          victoryOverlay.classList.remove("fadeIn");
          victoryOverlay.style.display = "none";
          const emojiRows = Array.from(document.querySelectorAll("#resultLog > div"))
            .map(row => row.textContent)
            .filter(txt => txt.includes("âš”ï¸") || txt.includes("ðŸ”¥") || txt.includes("ðŸ”¨"))
            .join("\n");
          const shareBlock = document.getElementById("shareBlock");
          const shareLines = lastPlayedTurn.map(name =>
            `${getCardEmoji(name)} ${name.charAt(0).toUpperCase() + name.slice(1)}`
          );
          const header = "ðŸƒ Lethal #001\nðŸ† Defeated the Goblin King in " +
            document.querySelectorAll("#resultLog > div").length + " turn(s)!\n\n";
          const shareFormatted = header + shareLines.join("  ");
          shareBlock.textContent = shareFormatted;
          navigator.clipboard.writeText(shareFormatted);
          const modal = document.getElementById("endScreen");
          modal.style.display = "flex";
          document.getElementById("copyBtn").onclick = () => {
            navigator.clipboard.writeText(shareFormatted);
            document.getElementById("copyBtn").textContent = "Copied!";
          };
        }, 1500);
      }, 1000);
    }
  
    function showFailedAttempt() {
      const playArea = document.getElementById("playArea");
      const guessRow = document.createElement("div");
      guessRow.classList.add("guess-row");
      guessRow.style.display = "flex";
      guessRow.style.marginBottom = "1rem";
      guessRow.style.justifyContent = "center";
      guessRow.style.gap = "0.5rem";
      lastPlayedTurn.forEach(name => {
        const box = document.createElement("div");
        box.textContent = getCardEmoji(name);
        box.style.width = "48px";
        box.style.height = "48px";
        box.style.fontSize = "2rem";
        box.style.display = "flex";
        box.style.alignItems = "center";
        box.style.justifyContent = "center";
        box.style.background = "#1e1e1e";
        box.style.border = "2px solid #333";
        box.style.borderRadius = "0.5rem";
        guessRow.appendChild(box);
      });
      document.getElementById("resultLog").appendChild(guessRow);
      const cards = Array.from(playArea.querySelectorAll(".card"));
      cards.forEach(card => {
        document.getElementById("hand").appendChild(card);
        initCardEvents(card);
      });
    }
  
    function getCardEmoji(cardName) {
      switch (cardName) {
        case "strike": return "âš”ï¸";
        case "fireball": return "ðŸ”¥";
        case "bash": return "ðŸ”¨";
        default: return "â“";
      }
    }
  
    function addTurnResult(cardNames) {
      const log = document.getElementById("resultLog");
      const row = document.createElement("div");
      row.style.fontSize = "1.5rem";
      row.style.margin = "0.5rem 0";
      row.textContent = cardNames
        .map(name => `${getCardEmoji(name)} ${name.charAt(0).toUpperCase() + name.slice(1)}`)
        .join("  ");
      log.appendChild(row);
    }
  
    function hideCardOverlay() {
      document.getElementById("cardOverlay").style.display = "none";
    }
  </script>
</body>
</html>
